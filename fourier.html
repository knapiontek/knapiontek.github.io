<!DOCTYPE html>
<html>
<head>
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css' integrity='sha384-wE+lCONuEo/QSfLb4AfrSk7HjWJtc4Xc1OiB2/aDBzHzjnlBP4SX7vjErTcwlA8C' crossorigin='anonymous'>
<link rel='stylesheet' href='common.css'>
<script src='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js' integrity='sha384-tdtuPw3yx/rnUGmnLNWXtfjb9fpmwexsd+lr6HUYnUY4B7JhB5Ty7a1mYd+kto/s' crossorigin='anonymous'></script>
<script src='https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script>
<script src='util.js'></script>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<style>
#simulation, #spectrum {
    position: relative;
    width: 650px;
    height: 350px;
    margin-left: auto;
    margin-right: auto;
    display: block;
    border: thin solid;
}
</style></head>
<body>
<div id='main_page'>

<h4>Fourier Series</h4>
<p>We assume that a periodic function can be represented by a sum of harmonics as follows</p>
<math>x(t) = \frac{a_0}{2}+\sum_{n=1}^\infty a_n\cos(n\omega_0t) + \frac{b_0}{2}+\sum_{n=1}^\infty b_n\sin(n\omega_0t)</math>

<p>For simplicity let's consider first an even function which looks like</m></p>
<math>x_e(t) = \sum_{n=1}^\infty a_n\cos(n\omega_0t)</math>

<p>We manipulate it in order to extract <m>a_n</m></p>
<math>
\begin{aligned}
x_e(t)\cos(m\omega_0t) &= \sum_{n=1}^\infty a_n\cos(n\omega_0t)\cos(m\omega_0t) \\
\\
\int_T x_e(t)\cos(m\omega_0t)dt &= \int_T \sum_{n=1}^\infty a_n\cos(n\omega_0t)\cos(m\omega_0t)dt \\
\\
&= \sum_{n=1}^\infty a_n\int_T\cos(n\omega_0t)\cos(m\omega_0t)dt \\
\\
&= \sum_{n=1}^\infty a_n \int_T {1 \over 2}\Bigl[\cos((m+n)\omega_0t)+\cos((m-n)\omega_0t)\Bigr]dt \\
\\
&= {1\over 2}\sum_{n=1}^\infty a_n\int_T\Bigl[\cos((m+n)\omega_0t)+\cos((m-n)\omega_0t)\Bigr]dt \\
\\
&= {1\over 2}\sum_{n=1}^\infty a_n\int_T\cos((m+n)\omega_0t)dt + {1\over 2}\sum_{n=1}^\infty a_n\int_T\cos((m-n)\omega_0t)dt \\
\\
&= 0 + {1\over 2} a_mT
\end{aligned}
</math>

<p>Where cosine integral over full number of periods equals zero</p>
<math>\int_T\cos((m+n)\omega_0t)dt=0</math>
<math>
\int_T\cos((m-n)\omega_0t)dt =
\begin{cases}
0\quad m\ne n \\
\int_T\cos(0)dt = T\quad m=n
\end{cases}
</math>

<p>Therefore</p>
<math>a_m = {2\over T}\int_Tx_e(t)\cos(m\omega_0t)dt</math>

<p>Finally we can generalize the formula for coefficients <m>n \in 0,1,2,...</m></p>
<math>
\begin{aligned}
a_n = {2\over T}\int_Tx(t)\cos(n\omega_0t)dt \\
\\
b_n = {2\over T}\int_Tx(t)\sin(n\omega_0t)dt
\end{aligned}
</math>

<h4>Forward Discrete Fourier Transform (DFT)</h4>
<math>X_k = \sum_{n=0}^{N-1}x_ne^{-i2\pi kn/N}</math>
<ul>
<li><m>N</m> - total number of function samples</li>
<li><m>n</m> - index of a function sample</li>
<li><m>k</m> - index of a harmonic</li>
</ul>

<h4>Inverse Discrete Fourier Transform (IDFT)</h4>
<math>x_n = \frac{1}{N}\sum_{k=0}^{N-1}X_ke^{i2\pi kn/N}</math>

<h4>Fast Fourier Transform (FFT)</h4>

<p>Let's notice</p>
<math>
\begin{aligned}
X_{N + k} &= \sum_{n=0}^{N-1}x_ne^{-i2\pi(N+k)n/N} \\
\\
&= \sum_{n=0}^{N-1}x_ne^{-i2\pi n}e^{-i 2\pi kn/N} \\
\\
&= \sum_{n=0}^{N-1}x_ne^{-i2\pi kn/N}
\end{aligned}
</math>
<p>Where Euler Identity</p>
<math>e^{i2\pi n} = 1 \quad n \in 0,1,2,...</math>
<p>Yields to</p>
<math>
X_{k+nN} = X_k \quad n \in 0,1,2,...
</math>

<p>It allows us manipulation as follows</p>
<math>
\begin{aligned}
X_k &= \sum_{n=0}^{N-1}x_ne^{-i 2\pi kn/N} \\
\\
&= \sum_{m=0}^{N/2-1}x_{2m}e^{-i2\pi k(2m)/N}+\sum_{m=0}^{N/2-1}x_{2m+1}e^{-i2\pi k(2m+1)/N} \\
\\
&= \sum_{m=0}^{N/2-1}x_{2m}e^{-i2\pi km/(N/2)}+e^{-i 2\pi k/N}\sum_{m=0}^{N/2-1}x_{2m+1}e^{-i2\pi km/(N/2)}
\end{aligned}
</math>

<p>The above step can be executed recursively gaining <m>\mathcal{O}(N^2) \rightarrow \mathcal{O}(NlogN)</m></p>

<h4>Simulation</h4>
<p>Press [+] or [-] to change number of valid harmonics: <i id='valid_harmonics'>valid_harmonics</i></p>
<div id='simulation'></div>

<h4>Spectrum</h4>
<div id='spectrum'></div>

</div>
<script>
var canvas_real = Canvas('#simulation')
var canvas_spectrum = Canvas('#spectrum')
function run_calculation(valid_harmonics) {
    canvas_real.erase()
    canvas_spectrum.erase()

    var margin = 10
    var x1 = margin
    var x2 = canvas_real.width() - margin
    var y1 = margin
    var y2 = canvas_real.height() - margin

    canvas_real.pike_line(Point2D(x1, y2), Point2D(x1, y1))
    canvas_real.pike_line(Point2D(x1, y2), Point2D(x2, y2))
    canvas_spectrum.pike_line(Point2D(x1, y2), Point2D(x1, y1))
    canvas_spectrum.pike_line(Point2D(x1, y2), Point2D(x2, y2))

    var sample_no = 100
    var max_val = 10

    function scale_real(x, y) {
        var scale_x = (x2 - x1) / sample_no
        var scale_y = (y2 - y1) / (3/2) / max_val
        return Point2D(margin + scale_x * x, y2 - margin - scale_y * y)
    }

    function scale_spectrum(x, y) {
        var scale_x = (x2 - x1) / sample_no
        var scale_y = (y2 - y1) / max_val / max_val / max_val * 3
        return Point2D(margin + scale_x * x, y2 - margin - scale_y * y)
    }

    // simetric signal avoid sine
    var input = []
    for(var i = 0; i < sample_no; i += 1) {
        var val = 0
        if(25 < i && i < 75)
            val = max_val
        input[i] = val
    }

    // signal is simetric => sine == 0
    var spectrum = []
    for(var i1 = 0; i1 < sample_no; i1 += 1) {
        var freq = 0.0
        for(var i2 = 0; i2 < sample_no; i2 += 1) {
            var angle = -2*Math.PI*i1*i2/sample_no
            freq += input[i2] * Math.cos(angle)
        }
        spectrum[i1] = freq
    }

    // inversed for only valid_harmonics
    var inversed = []
    for(var i1 = 0; i1 < sample_no; i1 += 1) {
        var sample = 0
        for(var i2 = 0; i2 < valid_harmonics; i2 += 1) {
            var angle1 = 2*Math.PI*i1*i2/sample_no
            sample += spectrum[i2] * Math.cos(angle1)
            var angle2 = 2*Math.PI*i1*(sample_no-1-i2)/sample_no
            sample += spectrum[sample_no-1-i2] * Math.cos(angle2)
        }
        inversed[i1] = sample / sample_no
    }

    var real_path = canvas_real.Path({stroke:'blue'})
    real_path.move_to(scale_real(input[0]))
    for(var i = 1; i < sample_no; i += 1) {
        real_path.line_to(scale_real(i, input[i]))
    }
    real_path.stroke()

    var harmonic_path = canvas_real.Path({stroke:'red'})
    harmonic_path.move_to(scale_real(inversed[0]))
    for(var i = 0; i < sample_no; i += 1) {
        harmonic_path.line_to(scale_real(i, inversed[i]))
    }
    harmonic_path.stroke()

    var styles = [{fill:'red'}, {fill:'blue'}]
    for(var i = 0; i < sample_no; i += 1) {
        var amplitude = Math.abs(spectrum[i])
        if(Math.abs(amplitude-10) > 1e-11) {
            var style = styles[(i > valid_harmonics && i < sample_no-valid_harmonics)|0]
            canvas_spectrum.dot(scale_spectrum(i, amplitude), 2, style)
        }
    }
}
var valid_harmonics = 5
run_calculation(valid_harmonics)
render_katex()
$('#valid_harmonics').text(valid_harmonics)
$(window).keydown(function(event) {
    switch(event.which) {
        case 107:
            valid_harmonics += 1
            if(valid_harmonics > 50) valid_harmonics = 50
            $('#valid_harmonics').text(valid_harmonics)
            run_calculation(valid_harmonics)
            break
        case 109:
            valid_harmonics -= 1
            if(valid_harmonics < 1) valid_harmonics = 1
            $('#valid_harmonics').text(valid_harmonics)
            run_calculation(valid_harmonics)
            break
        default:
            return
    }
})
</script>
</body>
</html>
